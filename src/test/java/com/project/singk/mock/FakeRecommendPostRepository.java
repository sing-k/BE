package com.project.singk.mock;

import com.project.singk.domain.post.controller.request.FilterSort;
import com.project.singk.domain.post.controller.request.PostSort;
import com.project.singk.domain.post.domain.RecommendPost;
import com.project.singk.domain.post.service.port.RecommendPostRepository;
import com.project.singk.global.api.ApiException;
import com.project.singk.global.api.AppHttpStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

public class FakeRecommendPostRepository implements RecommendPostRepository {
	private final AtomicLong autoGeneratedId = new AtomicLong(0);
	private final List<RecommendPost> data = Collections.synchronizedList(new ArrayList<>());

    @Override
    public RecommendPost save(RecommendPost recommendPost) {
        if (recommendPost.getId() == null || recommendPost.getId() == 0) {
            RecommendPost newRecommendPost = RecommendPost.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .title(recommendPost.getTitle())
                    .content(recommendPost.getContent())
                    .recommend(recommendPost.getRecommend())
                    .genre(recommendPost.getGenre())
                    .link(recommendPost.getLink())
                    .likes(recommendPost.getLikes())
                    .comments(recommendPost.getComments())
                    .member(recommendPost.getMember())
                    .createdAt(recommendPost.getCreatedAt())
                    .modifiedAt(recommendPost.getModifiedAt())
                    .build();
            data.add(newRecommendPost);
            return newRecommendPost;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), recommendPost.getId()));
            data.add(recommendPost);
            return recommendPost;
        }
    }

    @Override
    public List<RecommendPost> saveAll(List<RecommendPost> posts) {
        return posts.stream()
                .map(this::save)
                .toList();
    }

    @Override
    public RecommendPost getById(Long id) {
        return findById(id).orElseThrow(() -> new ApiException(AppHttpStatus.NOT_FOUND_POST));
    }

    @Override
    public Optional<RecommendPost> findById(Long id) {
        return data.stream().filter(item -> item.getId().equals(id)).findAny();
    }

    @Override
    public Page<RecommendPost> findAll(int offset, int limit, String sort, String filter, String keyword) {
        List<RecommendPost> posts = data.stream()
                .sorted(order(PostSort.valueOf(sort)))
                .filter(item -> search(item, filter, keyword))
                .limit(limit)
                .skip(offset)
                .toList();

        Pageable pageable = PageRequest.ofSize(limit);

        return new PageImpl<>(
                posts,
                pageable,
                data.stream()
                        .filter(item -> search(item, filter, keyword))
                        .count()
        );
    }

    @Override
    public Page<RecommendPost> findAllByMemberId(Long memberId, int offset, int limit) {
        List<RecommendPost> posts = data.stream()
                .sorted(order(PostSort.LATEST))
                .filter(item -> item.getMember().getId().equals(memberId))
                .limit(limit)
                .skip(offset)
                .toList();

        Pageable pageable = PageRequest.ofSize(limit);

        return new PageImpl<>(
                posts,
                pageable,
                data.stream()
                        .filter(item -> item.getMember().getId().equals(memberId))
                        .count()
        );
    }

    @Override
    public void deleteById(Long postId) {
        data.removeIf(item -> item.getId().equals(postId));
    }

    private Comparator<RecommendPost> order(PostSort sort) {
        return switch (sort) {
            case LATEST -> Comparator.comparing(RecommendPost::getCreatedAt).reversed();
            case LIKES -> Comparator.comparing(RecommendPost::getLikes).reversed();
        };
    }
    private boolean search(RecommendPost post, String filter, String keyword) {
        if (!StringUtils.hasText(filter) || !StringUtils.hasText(keyword)) return true;

        FilterSort filterSort = FilterSort.valueOf(filter);

        return switch (filterSort) {
            case TITLE -> post.getTitle().contains(keyword);
            case CONTENT -> post.getContent().contains(keyword);
            case WRITER -> post.getMember().getNickname().contains(keyword);
        };
    }
}
