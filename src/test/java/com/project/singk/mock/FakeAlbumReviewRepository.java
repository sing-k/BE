package com.project.singk.mock;

import com.project.singk.domain.album.domain.Album;
import com.project.singk.domain.member.domain.Gender;
import com.project.singk.domain.member.domain.Member;
import com.project.singk.domain.review.controller.request.ReviewSort;
import com.project.singk.domain.review.domain.AlbumReview;
import com.project.singk.domain.review.domain.AlbumReviewStatistics;
import com.project.singk.domain.review.service.port.AlbumReviewRepository;
import com.project.singk.global.api.ApiException;
import com.project.singk.global.api.AppHttpStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

public class FakeAlbumReviewRepository implements AlbumReviewRepository {
	private final AtomicLong autoGeneratedId = new AtomicLong(0);
	private final List<AlbumReview> data = Collections.synchronizedList(new ArrayList<>());

    @Override
    public AlbumReview save(AlbumReview albumReview) {
        if (albumReview.getId() == null || albumReview.getId() == 0) {
            AlbumReview newAlbumReview = AlbumReview.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .content(albumReview.getContent())
                    .score(albumReview.getScore())
                    .prosCount(albumReview.getProsCount())
                    .consCount(albumReview.getConsCount())
                    .album(albumReview.getAlbum())
                    .reviewer(albumReview.getReviewer())
                    .build();
            data.add(newAlbumReview);
            return newAlbumReview;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), albumReview.getId()));
            data.add(albumReview);
            return albumReview;
        }
    }

    @Override
    public List<AlbumReview> saveAll(List<AlbumReview> albumReviews) {
        return albumReviews.stream().map(this::save).toList();
    }

    @Override
    public AlbumReview getById(Long id) {
        return findById(id).orElseThrow(() -> new ApiException(AppHttpStatus.NOT_FOUND_ALBUM_REVIEW));
    }

    @Override
    public Optional<AlbumReview> findById(Long id) {
        return data.stream().filter(item -> item.getId().equals(id)).findAny();
    }

    @Override
    public boolean existsByMemberAndAlbum(Member member, Album album) {
        return data.stream().anyMatch(item ->
                item.getReviewer().getId().equals(member.getId()) &&
                item.getAlbum().getId().equals(album.getId()));
    }

    @Override
    public Page<AlbumReview> getAllByAlbumId(String albumId, int offset, int limit, String sort) {
        List<AlbumReview> reviews = data.stream()
                .sorted(sortBy(ReviewSort.valueOf(sort)))
                .filter(item -> item.getAlbum().getId().equals(albumId))
                .skip(offset)
                .limit(limit)
                .toList();

        long count = data.stream()
                .filter(item -> item.getAlbum().getId().equals(albumId))
                .count();

        Pageable pageable = PageRequest.ofSize(limit);

        return new PageImpl<>(reviews, pageable, count);
    }

    @Override
    public Page<AlbumReview> getAllByMemberId(Long memberId, int offset, int limit, String sort) {
        List<AlbumReview> reviews = data.stream()
                .sorted(sortBy(ReviewSort.valueOf(sort)))
                .filter(item -> item.getReviewer().getId().equals(memberId))
                .skip(offset)
                .limit(limit)
                .toList();

        long count = data.stream()
                .filter(item -> item.getReviewer().getId().equals(memberId))
                .count();

        Pageable pageable = PageRequest.ofSize(limit);

        return new PageImpl<>(reviews, pageable, count);
    }

    @Override
    public void delete(AlbumReview albumReview) {
        data.removeIf(item -> item.getId().equals(albumReview.getId()));
    }

    private Comparator<AlbumReview> sortBy(ReviewSort sort) {
        return switch (sort) {
            case NEW -> Comparator.comparing(AlbumReview::getCreatedAt).reversed();
            case LIKES -> Comparator.comparing(AlbumReview::getProsCount).reversed();
        };
    }
}
