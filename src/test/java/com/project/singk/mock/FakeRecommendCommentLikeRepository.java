package com.project.singk.mock;

import com.project.singk.domain.like.domain.RecommendCommentLike;
import com.project.singk.domain.like.service.port.RecommendCommentLikeRepository;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

public class FakeRecommendCommentLikeRepository implements RecommendCommentLikeRepository {
	private final AtomicLong autoGeneratedId = new AtomicLong(0);
	private final List<RecommendCommentLike> data = Collections.synchronizedList(new ArrayList<>());

    @Override
    public RecommendCommentLike save(RecommendCommentLike recommendCommentLike) {
        if (recommendCommentLike.getId() == null || recommendCommentLike.getId() == 0) {
            RecommendCommentLike newRecommendCommentLike = RecommendCommentLike.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .comment(recommendCommentLike.getComment())
                    .member(recommendCommentLike.getMember())
                    .build();
            data.add(newRecommendCommentLike);
            return newRecommendCommentLike;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), recommendCommentLike.getId()));
            data.add(recommendCommentLike);
            return recommendCommentLike;
        }
    }

    @Override
    public Optional<RecommendCommentLike> findByMemberIdAndCommentId(Long memberId, Long commentId) {
        return data.stream()
                .filter(item -> item.getMember().getId().equals(memberId) && item.getComment().getId().equals(commentId))
                .findAny();
    }

    @Override
    public boolean existsByMemberIdAndCommentId(Long memberId, Long commentId) {
        return data.stream()
                .anyMatch(item -> item.getMember().getId().equals(memberId) && item.getComment().getId().equals(commentId));
    }

    @Override
    public void deleteById(Long likeId) {
        data.removeIf(item -> item.getId().equals(likeId));
    }

}
